#!/bin/bash
# Initramfs Post-Update hook to generate boot.img inside /boot
set -eo pipefail

version="$1"
if [[ -z "$version" ]]; then
	echo >&2 "W: rpi-boot-img: ${DPKG_MAINTSCRIPT_PACKAGE:-kernel package} did not pass a version number"
	exit 2
fi

# read config vars
source /etc/initramfs/rpi-vars.sh

echo "Running RPI ramdisk generator for version $version..."

BOOT_IMG=/boot/boot.img
BOOT_IMG_SIZE=30  # MB
BOOT_MOUNTPOINT=/tmp/rpi-boot-img

dd if=/dev/zero bs=1M count=$BOOT_IMG_SIZE of="$BOOT_IMG"
losetup /dev/loop8 "$BOOT_IMG"
# close the loop device on every exit status using a trap
cleanup() {
	set +e
	umount /dev/loop8
	losetup -d /dev/loop8
}
trap 'cleanup' EXIT

# Format the boot img partition as FAT32
mkfs.vfat -n RPI_BOOT_RD /dev/loop8
mkdir -p "$BOOT_MOUNTPOINT"
mount /dev/loop8 "$BOOT_MOUNTPOINT"

install "/boot/vmlinuz-$version" "$BOOT_MOUNTPOINT/kernel8.img"
install "/boot/initrd.img-$version" "$BOOT_MOUNTPOINT/initrd.img"
for file in "${RPI_FIRMWARE_FILES[@]}"; do
	if [[ "$file" == "/"* ]]; then
		# absolute path, copy it
		cp -f "$file" "$BOOT_MOUNTPOINT/$(basename "$file")"
	else
		# download the latest rpi firmware files (debian repo is outdated)
		wget "https://github.com/raspberrypi/firmware/raw/master/boot/$file" \
			-O "$BOOT_MOUNTPOINT/$file"
	fi
done

cat <<EOF > "$BOOT_MOUNTPOINT"/config.txt
# dtoverlay=vc4-kms-v3d
dtparam=i2c_vc=on
arm_64bit=1
initramfs initrd.img followkernel
enable_uart=1
otg_mode=1
boot_delay=1
disable_overscan=1
disable_splash=1
$RPI_CONFIG
EOF

cat <<EOF > "$BOOT_MOUNTPOINT/cmdline.txt"
console=serial0,115200 console=tty1 root=PARTLABEL=RPIOSRoot rootwait rw fsck.repair=yes net.ifnames=0 $RPI_CMDLINE
EOF

echo "RPI boot ramdisk '$BOOT_IMG' successfull generated!"
ls -lh "$BOOT_MOUNTPOINT"

exit 0

